# Testing Best Practice

In the section below, we're going to discuss what practices you should adopt when testing to ensure that the tests you write are able to correctly verify the expected behavior of the code.

## Needed Tools

1. Version Control
2. Programming Language/Platform
3. Linter
4. Test Harness
5. Code Coverage Tool

## Setup

1. Ensure that `node >= 8.6` is installed
2. Run `npm install`
3. Run `npm test`, you should expect to see the linter passing but some test failing and some code coverage
4. Run `npm run report` to see the coverage reports
5. Run `npm run test:watch` to have tests automatically rerun when changes are made

## Goals

Our goals in the following exercises are:

1. Adopt best practice in using our test harness
2. Adopt best practice in maintaining our test suite

## Steps

Our steps will be the following:

1. Familiarize yourself with the coverage report by looking at the web page generated by `npm run report`. Click through the directories and source and test files to make sure you understand how to read the report.
    
    **Using the report is best practice because it gives us a visual understanding of our code coverage and tells us specifically where we need to improve.**
2. Familiarize yourself with the test watcher by running `npm run test:watch` and make a change to see the tests being automatically rerun.

    **Using the test watcher is best practice because it allows us to save time when writing our code and eliminates the possibility we forget to run our linter and tests. This will ensure that before we commit, we can have a guarantee our entire suite passes.**
3. Fix the test in `tests/missing_statement.test.js` by removing the `try/catch`. The catch block is never executed in our test file and should be removed because it could lead to a bug later when our code changes. You should see coverage go to `100%`.

    **It's important to make sure that our test files are always at `100%` coverage because any non covered code is where bugs could live. Because tests are code, they can also contain bugs. The biggest risk in tests is creating a `false positive` because it means our test is passing but actually the result of the code is incorrect. This will lead us to continuing to deploy our code to production and can result in a bug**
    
4. Change the test cases in `tests/expect_specific.test.js` to expect the specific output rather than the general data type when possible. Even though we have achieved 100% coverage in this file, it does not mean that there cannot be any bug in the future. We're able to catch basic problems related to type but we are not guarding against logical bugs when our code changes in the future.

	**It's important to expect the exact value rather than the type because if our logic changes, it could still produce the same type of data but the result is incorrect. We want our test suite to give us advanced notice when our code is producing incorrect behavior.**
	
5. Add tests for the different functions in `tests/functions.test.js` to get the entire file coverage level to `100%`. Different kinds of functions will have different ways of being tested for their return value and errors.

	**It's important to test functions using the appropriate style. Because we're using JavaScript, we need to be able to deal with vanilla functions, callback, and async/await properly**
	
6. Avoid the use of variables in your result expectations. Change the tests in `tests/no_variable.test.js` to remove the use of variables in the expectation of the response. This is in order to prevent the possibility of a change in the behavior of the code that our code does not catch. For values that we cannot know the specific value of beforehand like random values, dates, and autogenerated ids, we need to at least check the type before using it as a variable.

	**It's important to test with the exact values and at least check the type of the response if we want to use it in our expectation in order to prevent cases in which we're expecting `undefined === undefined` which will always be `true` and pass. Then we will incorrectly think everything is fine.**

7. Ensure that your `describe` and `it` blocks are properly named and organized so that when your tests run in the shell, you will be easily able to identify what went wrong. Change the test structure in `tests/structure.test.js` to ensure that the `describe` blocks capture the unit under test and the `it` blocks capture the expected outputs of the function.

	**Our tests should serve as an early warning against incorrect changes or behavior so it's absolutely important that they can inform us quickly.**

8. Ensure that you properly test for logical edge cases. You should test your code from the perspective of someone who did not write the code. Remember that simply having `100%` code coverage does not mean you have no bugs in your code. Change the tests in `tests/logical_edge_cases.test.js` to add another case to expose the bug in the code.

	**It's important to test more than a single case when you have a function that is responsible for logic. In these cases, having full coverage does not by itself guarantee that the logic is correct. Thinking from the perspective of someone who didn't write the code will allow you to find cases that fully exercise the code to ensure it's correct under all cases**

## Conclusion

Congratulations! We've just finished identifying and adopting best practices when it comes to using our testing tools and when writing the test cases themselves.